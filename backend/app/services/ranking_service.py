"""
‰∏™ÊÄßÂåñËÇ°Á•®ÊéíÂêçÊúçÂä°
Âü∫‰∫éÁúüÂÆûÂ∏ÇÂú∫Êï∞ÊçÆÂÆûÁé∞Â§öÁª¥Â∫¶ÊéíÂêçÁÆóÊ≥ï
"""
import logging
from typing import List, Dict, Any, Optional
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, text, desc, asc
from datetime import datetime, timedelta

from app.models.stock import Stock, StockPrice

logger = logging.getLogger(__name__)


class StockRankingService:
    """ËÇ°Á•®ÊéíÂêçÊúçÂä°"""
    
    def __init__(self, session: AsyncSession):
        self.session = session
    
    async def get_activity_ranking(self, limit: int = 10) -> List[Dict[str, Any]]:
        """
        Ê¥ªË∑ÉÂ∫¶ÊéíÂêç - Âü∫‰∫éÊàê‰∫§Èáè
        ‰ºòÂÖàÁ∫ß: 1
        """
        try:
            query = text("""
                SELECT 
                    s.symbol,
                    s.name,
                    s.sector,
                    sp.close as current_price,
                    sp.volume,
                    sp.volume * sp.close as turnover,
                    RANK() OVER (ORDER BY sp.volume DESC) as volume_rank,
                    RANK() OVER (ORDER BY sp.volume * sp.close DESC) as turnover_rank
                FROM stocks s
                INNER JOIN stock_prices sp ON s.id = sp.stock_id
                WHERE s.symbol IN ('AAPL','MSFT','NVDA','META','NFLX','PYPL','INTC','CSCO','ADBE','QCOM')
                AND sp.date = (
                    SELECT MAX(date) FROM stock_prices WHERE stock_id = s.id
                )
                ORDER BY sp.volume DESC
                LIMIT :limit
            """)
            
            result = await self.session.execute(query, {"limit": limit})
            rows = result.fetchall()
            
            rankings = []
            for i, row in enumerate(rows, 1):
                symbol, name, sector, price, volume, turnover, vol_rank, turn_rank = row
                
                rankings.append({
                    "rank": i,
                    "symbol": symbol,
                    "name": name,
                    "sector": sector,
                    "current_price": float(price) if price else 0,
                    "volume": int(volume) if volume else 0,
                    "turnover": float(turnover) if turnover else 0,
                    "volume_rank": int(vol_rank) if vol_rank else 0,
                    "turnover_rank": int(turn_rank) if turn_rank else 0,
                    "activity_score": self._calculate_activity_score(volume, turnover),
                    "ranking_type": "activity"
                })
            
            logger.info(f"Generated activity ranking for {len(rankings)} stocks")
            return rankings
            
        except Exception as e:
            logger.error(f"Error generating activity ranking: {e}")
            return []
    
    async def get_volatility_ranking(self, limit: int = 10) -> List[Dict[str, Any]]:
        """
        Ê≥¢Âä®ÊÄßÊéíÂêç - Âü∫‰∫éÊó•ÂÜÖÊåØÂπÖÂíå‰ª∑Ê†ºÊ≥¢Âä®
        ‰ºòÂÖàÁ∫ß: 2
        """
        try:
            query = text("""
                SELECT 
                    s.symbol,
                    s.name,
                    s.sector,
                    sp.close as current_price,
                    sp.high,
                    sp.low,
                    sp.open,
                    (sp.high - sp.low) as daily_range,
                    ((sp.high - sp.low) / sp.close * 100) as volatility_percent,
                    ABS(sp.close - sp.open) as intraday_move,
                    (ABS(sp.close - sp.open) / sp.open * 100) as move_percent
                FROM stocks s
                INNER JOIN stock_prices sp ON s.id = sp.stock_id
                WHERE s.symbol IN ('AAPL','MSFT','NVDA','META','NFLX','PYPL','INTC','CSCO','ADBE','QCOM')
                AND sp.date = (
                    SELECT MAX(date) FROM stock_prices WHERE stock_id = s.id
                )
                ORDER BY ((sp.high - sp.low) / sp.close * 100) DESC
                LIMIT :limit
            """)
            
            result = await self.session.execute(query, {"limit": limit})
            rows = result.fetchall()
            
            rankings = []
            for i, row in enumerate(rows, 1):
                symbol, name, sector, price, high, low, open_price, daily_range, volatility_pct, intraday_move, move_pct = row
                
                rankings.append({
                    "rank": i,
                    "symbol": symbol,
                    "name": name,
                    "sector": sector,
                    "current_price": float(price) if price else 0,
                    "high": float(high) if high else 0,
                    "low": float(low) if low else 0,
                    "open": float(open_price) if open_price else 0,
                    "daily_range": float(daily_range) if daily_range else 0,
                    "volatility_percent": float(volatility_pct) if volatility_pct else 0,
                    "intraday_move": float(intraday_move) if intraday_move else 0,
                    "move_percent": float(move_pct) if move_pct else 0,
                    "volatility_score": self._calculate_volatility_score(volatility_pct, move_pct),
                    "ranking_type": "volatility"
                })
            
            logger.info(f"Generated volatility ranking for {len(rankings)} stocks")
            return rankings
            
        except Exception as e:
            logger.error(f"Error generating volatility ranking: {e}")
            return []
    
    async def get_performance_ranking(self, limit: int = 10) -> List[Dict[str, Any]]:
        """
        Ê∂®Ë∑åÊéíÂêç - Âü∫‰∫éÂΩìÊó•Ë°®Áé∞
        ‰ºòÂÖàÁ∫ß: 3  
        """
        try:
            query = text("""
                SELECT 
                    s.symbol,
                    s.name,
                    s.sector,
                    sp.close as current_price,
                    sp.open,
                    (sp.close - sp.open) as price_change,
                    ((sp.close - sp.open) / sp.open * 100) as percent_change,
                    sp.volume,
                    CASE 
                        WHEN sp.close > sp.open THEN 'UP'
                        WHEN sp.close < sp.open THEN 'DOWN'
                        ELSE 'FLAT'
                    END as direction,
                    CASE 
                        WHEN sp.close > sp.open THEN 'üî∫'
                        WHEN sp.close < sp.open THEN 'üîª'
                        ELSE '‚û°Ô∏è'
                    END as trend_emoji
                FROM stocks s
                INNER JOIN stock_prices sp ON s.id = sp.stock_id
                WHERE s.symbol IN ('AAPL','MSFT','NVDA','META','NFLX','PYPL','INTC','CSCO','ADBE','QCOM')
                AND sp.date = (
                    SELECT MAX(date) FROM stock_prices WHERE stock_id = s.id
                )
                ORDER BY ((sp.close - sp.open) / sp.open * 100) DESC
                LIMIT :limit
            """)
            
            result = await self.session.execute(query, {"limit": limit})
            rows = result.fetchall()
            
            rankings = []
            for i, row in enumerate(rows, 1):
                symbol, name, sector, price, open_price, price_change, percent_change, volume, direction, trend_emoji = row
                
                rankings.append({
                    "rank": i,
                    "symbol": symbol,
                    "name": name,
                    "sector": sector,
                    "current_price": float(price) if price else 0,
                    "open_price": float(open_price) if open_price else 0,
                    "price_change": float(price_change) if price_change else 0,
                    "percent_change": float(percent_change) if percent_change else 0,
                    "volume": int(volume) if volume else 0,
                    "direction": direction,
                    "trend_emoji": trend_emoji,
                    "performance_score": abs(float(percent_change)) if percent_change else 0,
                    "ranking_type": "performance"
                })
            
            logger.info(f"Generated performance ranking for {len(rankings)} stocks")
            return rankings
            
        except Exception as e:
            logger.error(f"Error generating performance ranking: {e}")
            return []
    
    async def get_market_cap_ranking(self, limit: int = 10) -> List[Dict[str, Any]]:
        """
        Â∏ÇÂÄºÊéíÂêç - Âü∫‰∫éÂÖ¨Âè∏Â∏ÇÂÄº
        ‰ºòÂÖàÁ∫ß: 4
        """
        try:
            query = text("""
                SELECT 
                    s.symbol,
                    s.name,
                    s.sector,
                    s.market_cap,
                    sp.close as current_price,
                    sp.volume,
                    (s.market_cap / 1000000000) as market_cap_billions
                FROM stocks s
                INNER JOIN stock_prices sp ON s.id = sp.stock_id
                WHERE s.symbol IN ('AAPL','MSFT','NVDA','META','NFLX','PYPL','INTC','CSCO','ADBE','QCOM')
                AND sp.date = (
                    SELECT MAX(date) FROM stock_prices WHERE stock_id = s.id
                )
                AND s.market_cap IS NOT NULL
                ORDER BY s.market_cap DESC
                LIMIT :limit
            """)
            
            result = await self.session.execute(query, {"limit": limit})
            rows = result.fetchall()
            
            rankings = []
            for i, row in enumerate(rows, 1):
                symbol, name, sector, market_cap, price, volume, market_cap_billions = row
                
                rankings.append({
                    "rank": i,
                    "symbol": symbol,
                    "name": name,
                    "sector": sector,
                    "market_cap": float(market_cap) if market_cap else 0,
                    "market_cap_billions": float(market_cap_billions) if market_cap_billions else 0,
                    "current_price": float(price) if price else 0,
                    "volume": int(volume) if volume else 0,
                    "market_cap_score": self._calculate_market_cap_score(market_cap),
                    "ranking_type": "market_cap"
                })
            
            logger.info(f"Generated market cap ranking for {len(rankings)} stocks")
            return rankings
            
        except Exception as e:
            logger.error(f"Error generating market cap ranking: {e}")
            return []
    
    async def get_price_ranking(self, limit: int = 10) -> List[Dict[str, Any]]:
        """
        ‰ª∑Ê†ºÊéíÂêç - Âü∫‰∫éËÇ°Á•®‰ª∑Ê†º
        ‰ºòÂÖàÁ∫ß: 5
        """
        try:
            query = text("""
                SELECT 
                    s.symbol,
                    s.name,
                    s.sector,
                    sp.close as current_price,
                    sp.high,
                    sp.low,
                    sp.volume,
                    sp.open,
                    ((sp.close - sp.open) / sp.open * 100) as daily_change_pct
                FROM stocks s
                INNER JOIN stock_prices sp ON s.id = sp.stock_id
                WHERE s.symbol IN ('AAPL','MSFT','NVDA','META','NFLX','PYPL','INTC','CSCO','ADBE','QCOM')
                AND sp.date = (
                    SELECT MAX(date) FROM stock_prices WHERE stock_id = s.id
                )
                ORDER BY sp.close DESC
                LIMIT :limit
            """)
            
            result = await self.session.execute(query, {"limit": limit})
            rows = result.fetchall()
            
            rankings = []
            for i, row in enumerate(rows, 1):
                symbol, name, sector, price, high, low, volume, open_price, daily_change_pct = row
                
                rankings.append({
                    "rank": i,
                    "symbol": symbol,
                    "name": name,
                    "sector": sector,
                    "current_price": float(price) if price else 0,
                    "high": float(high) if high else 0,
                    "low": float(low) if low else 0,
                    "open": float(open_price) if open_price else 0,
                    "volume": int(volume) if volume else 0,
                    "daily_change_percent": float(daily_change_pct) if daily_change_pct else 0,
                    "price_score": float(price) if price else 0,
                    "ranking_type": "price"
                })
            
            logger.info(f"Generated price ranking for {len(rankings)} stocks")
            return rankings
            
        except Exception as e:
            logger.error(f"Error generating price ranking: {e}")
            return []
    
    async def get_comprehensive_ranking(self, limit: int = 10) -> List[Dict[str, Any]]:
        """
        ÁªºÂêàÊéíÂêç - Âü∫‰∫éÂ§öÁª¥Â∫¶Âä†ÊùÉÁÆóÊ≥ï
        """
        try:
            # Ëé∑ÂèñÂêÑÈ°πÊéíÂêç
            activity_ranking = await self.get_activity_ranking(limit)
            volatility_ranking = await self.get_volatility_ranking(limit)
            performance_ranking = await self.get_performance_ranking(limit)
            market_cap_ranking = await self.get_market_cap_ranking(limit)
            price_ranking = await self.get_price_ranking(limit)
            
            # ÊûÑÂª∫ÁªºÂêàËØÑÂàÜÂ≠óÂÖ∏
            comprehensive_scores = {}
            
            # ÊùÉÈáçÈÖçÁΩÆÔºàÊåâ‰Ω†ÁöÑ‰ºòÂÖàÁ∫ßÔºâ
            weights = {
                "activity": 0.3,      # ‰ºòÂÖàÁ∫ß1: 30%
                "volatility": 0.25,   # ‰ºòÂÖàÁ∫ß2: 25%
                "performance": 0.2,   # ‰ºòÂÖàÁ∫ß3: 20%
                "market_cap": 0.15,   # ‰ºòÂÖàÁ∫ß4: 15%
                "price": 0.1          # ‰ºòÂÖàÁ∫ß5: 10%
            }
            
            # Êî∂ÈõÜÊâÄÊúâËÇ°Á•®ÁöÑÂü∫Á°Ä‰ø°ÊÅØ
            all_rankings = {
                "activity": {item["symbol"]: item for item in activity_ranking},
                "volatility": {item["symbol"]: item for item in volatility_ranking},
                "performance": {item["symbol"]: item for item in performance_ranking},
                "market_cap": {item["symbol"]: item for item in market_cap_ranking},
                "price": {item["symbol"]: item for item in price_ranking}
            }
            
            # Ëé∑ÂèñÊâÄÊúâËÇ°Á•®Á¨¶Âè∑
            all_symbols = set()
            for ranking_data in all_rankings.values():
                all_symbols.update(ranking_data.keys())
            
            # ËÆ°ÁÆóÁªºÂêàËØÑÂàÜ
            for symbol in all_symbols:
                base_info = None
                weighted_score = 0
                dimension_scores = {}
                
                for dimension, weight in weights.items():
                    if symbol in all_rankings[dimension]:
                        item = all_rankings[dimension][symbol]
                        if base_info is None:
                            base_info = item  # ‰øùÂ≠òÂü∫Á°Ä‰ø°ÊÅØ
                        
                        # ËÆ°ÁÆóÊ†áÂáÜÂåñÂàÜÊï∞ (ÊéíÂêçË∂äÈ´òÂàÜÊï∞Ë∂äÈ´ò)
                        rank = item["rank"]
                        normalized_score = (limit - rank + 1) / limit * 100
                        dimension_scores[dimension] = normalized_score
                        weighted_score += normalized_score * weight
                    else:
                        dimension_scores[dimension] = 0
                
                if base_info:
                    comprehensive_scores[symbol] = {
                        **base_info,
                        "comprehensive_score": weighted_score,
                        "dimension_scores": dimension_scores,
                        "ranking_type": "comprehensive"
                    }
            
            # ÊåâÁªºÂêàËØÑÂàÜÊéíÂ∫è
            sorted_stocks = sorted(
                comprehensive_scores.values(),
                key=lambda x: x["comprehensive_score"],
                reverse=True
            )
            
            # ÈáçÊñ∞ÂàÜÈÖçÊéíÂêç
            for i, stock in enumerate(sorted_stocks[:limit], 1):
                stock["rank"] = i
            
            logger.info(f"Generated comprehensive ranking for {len(sorted_stocks[:limit])} stocks")
            return sorted_stocks[:limit]
            
        except Exception as e:
            logger.error(f"Error generating comprehensive ranking: {e}")
            return []
    
    def _calculate_activity_score(self, volume: int, turnover: float) -> float:
        """ËÆ°ÁÆóÊ¥ªË∑ÉÂ∫¶ËØÑÂàÜ"""
        if not volume:
            return 0
        # Êàê‰∫§ÈáèÊùÉÈáç70%ÔºåÊàê‰∫§È¢ùÊùÉÈáç30%
        volume_score = min(volume / 100_000_000 * 70, 70)  # 1‰∫øÊàê‰∫§ÈáèÂæóÊª°ÂàÜ
        turnover_score = min(turnover / 50_000_000_000 * 30, 30)  # 500‰∫øÊàê‰∫§È¢ùÂæóÊª°ÂàÜ
        return volume_score + turnover_score
    
    def _calculate_volatility_score(self, volatility_pct: float, move_pct: float) -> float:
        """ËÆ°ÁÆóÊ≥¢Âä®ÊÄßËØÑÂàÜ"""
        if not volatility_pct:
            return 0
        # Êó•ÂÜÖÊåØÂπÖÊùÉÈáç60%Ôºå‰ª∑Ê†ºÂèòÂä®ÊùÉÈáç40%
        range_score = min(volatility_pct * 10, 60)  # 6%ÊåØÂπÖÂæóÊª°ÂàÜ
        move_score = min(abs(move_pct) * 10, 40)    # 4%ÂèòÂä®ÂæóÊª°ÂàÜ
        return range_score + move_score
    
    def _calculate_market_cap_score(self, market_cap: float) -> float:
        """ËÆ°ÁÆóÂ∏ÇÂÄºËØÑÂàÜ"""
        if not market_cap:
            return 0
        # Â∏ÇÂÄºË∂äÂ§ßËØÑÂàÜË∂äÈ´òÔºå3‰∏á‰∫øÁæéÂÖÉÂæóÊª°ÂàÜ
        return min(market_cap / 3_000_000_000_000 * 100, 100)